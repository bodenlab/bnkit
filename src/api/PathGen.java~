/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package api;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import api.PartialOrderGraph;

/**
 *
 * @author ariane
 */
public class PathGen {
     /**
     * A queue holding the states to be searched.
     */
    PriorityQueue<QueueTiny<Object>> closedSet;
    PriorityQueue<QueueTiny<Object>> openSet;
    
    int costPenalty;
    
    PartialOrderGraph poag;
    
    HashMap<Integer, Integer> cameFrom;
    HashMap<Integer, Double> stepScoreMap;
    HashMap<Integer, Double> totalScoreMap;
    

    Integer startNode;
    Integer goalNode;
    
    public Queue<Integer[]> gaps;
    private HashMap<Integer, Integer> searchedList = null;
    
    private final int size;
    
    Integer[] sorted;
    public int goalID;
    public int startID;
    
     /**
     * The queue entry currently being processed.
     */
    protected QueueTiny<Object> currentEntry;
    QueueComparator queueComparator;
    
    
    
    public PathGen(PartialOrderGraph poag) {
        this.poag = poag;
        size = poag.getNodeIDs().length;
        searchedList = initSearchList();
        gaps = new LinkedList<>(); 
    }
    
    public void initAStarSearch(Integer startNode, Integer goalNode) {
        int queueSize = 10000; //Arbitary should change.
        this.goalNode = goalNode;
        this.startNode = startNode;

        
        costPenalty = 101; // The max cost is 100 (if the chance is 100% we get 
        // a cost of a move = 1, as every move should have some penalty 
        // associated (NEED TO ASK)
        
        // The comparator currently just compares on the cost + heuristic
        queueComparator = new QueueComparator();
        closedSet = new PriorityQueue<>(queueSize, queueComparator);
        
        // Open nodes
        openSet = new PriorityQueue<>(queueSize, queueComparator);  
        
        // Keeping track of how we got somewhere
        cameFrom = new HashMap<>();
        
        // Need to set the initial heuristics
        initScoreMaps();
        
        // Add the start node
        totalScoreMap.put(startNode, getHeuristic(startNode, goalNode));
    }
    
    
    /**
     * Initialises the score maps setting a max heuristic.
     */
    private void initScoreMaps() {
        // At the start the score is heuristic
        totalScoreMap = new HashMap<>();       
        Integer[] poagIDs = poag.getNodeIDs();
        for (Integer poagID : poagIDs) {
            totalScoreMap.put(poagID, getHeuristic(0, goalNode));
        }
    }
    
    /**
     * Gets the path with the least cost associated from an initial to goal node.
     * @return 
     */
    public List<Integer> getMainPath() {
        // Add the first position to the open set
        openSet.add(new QueueTiny<>(startNode, 0, getHeuristic(0, 0), startNode, null));
        totalScoreMap.put(startNode, getHeuristic(0, 0));
        cameFrom.put(0, startNode);
        while (!openSet.isEmpty()) {
            currentEntry = openSet.remove();
            closedSet.add(currentEntry);            
            if (Objects.equals(currentEntry.getCurrentPosition(), goalNode)) {
                // Check to make sure we didn't get straight there from the 
                // initial node, if we did return null and don't re add the gap
                if (Objects.equals(cameFrom.get(goalNode), startNode)) {
                    return null;
                }
                return(getPath());
            }
            searchNeighbours();
        }
        return null;
    }

    /**
     * Searches the neighboring nodes and updates the cost to these nodes if it
     * is less from this current node.
     */
    private void searchNeighbours() {        
        int currentID = currentEntry.getCurrentPosition();
        Map<Integer, Double> successors = poag.getOutEdgeWeights(currentID);
        Integer[] successorIds = poag.getNextNodeIDs(currentID);
        double heuristic = 100000; // An arbitarilty large initial heuristic.
        double currentCost = totalScoreMap.get(currentID);
        
        for (Integer neighborID : successorIds) {
            
            // This is if we are searching between gaps - we already know the
            // direct path is best so we want to skip the optimal path and find
            // the secondary one.
            if (neighborID == goalNode && currentID == startNode) {               
                continue;
            }
            int pos = isNodeSearched(neighborID);
            // If there has been no weight associated it will error out so we 
            // need to give it the maxinum cost of 0 (which is what the label says)
            double posCost = costPenalty;
            try {
                posCost = costPenalty - (100 * successors.get(neighborID)); //Because we want it to have some cost                                
            } catch(Exception e) {
                posCost = 200; // This has no weight associated need to ask!
                System.err.println("The ids didnt match the length of out " +
                    " weights: " + Arrays.toString(successorIds)+ "\n" + successors.toString());
            }
            heuristic = getHeuristic(0, 0);
            // Means it hasn't been searched yet otherwise we ignore it
            if (pos > 0) {
                // Get the total score to the 
                double totalMoveCost = currentCost + posCost;
                openSet.add(new QueueTiny<>(neighborID, totalMoveCost, heuristic, neighborID, currentID));
                // If its less than this is a better move than the current score
                // to get to that position - best path so far
                try {
                    if (totalMoveCost < totalScoreMap.get(neighborID)) {
                        cameFrom.put(neighborID, currentID);
                        totalScoreMap.put(neighborID, totalMoveCost);
                    }
                } catch(Exception e) {
                    //System.err.println("This node wasn't searchable? + " + neighborID);
                }
            }   
        }
        // Mark this node as searched
        setNodeSearched(currentID);
    }
    
    /**
     * Gets the heuristic between two nodes. 
     */
    private Double getHeuristic(Integer startNode, Integer goalNode) {
        return 100.0 * (goalNode - startNode);
    }

    /**
     * Gets the path - steps back through the path with the least cost.
     * @return most likely path.
     */
    private List<Integer> getPath() {
        int currId = currentEntry.getCurrentPosition();
        String totalPath = "" + currId;
        List<Integer> pathReverse = new ArrayList<>();
        pathReverse.add(currId);
        int prevId = 0;
        while (currId != startNode) {
            prevId = currId;
            try {
                currId = cameFrom.get(prevId);
            } catch(Exception e) {
                System.err.println(e);
                return null;
            }
            totalPath += "-" + currId;
            pathReverse.add(currId);
            // Means there is a gap so add it to the gaps
            if (prevId - currId != 1) {
                addGaps(currId, prevId);
                //System.err.println("Gap: " + prevId + " and " + currId);
            }
        }
        Collections.reverse(pathReverse);
        System.out.println(pathReverse);
        return pathReverse;
    }
    
     /**
     * Gets the search indication for a node
     * @param id
     * @return 0 for not searched and -1 if it has been searched
     */
    public int isNodeSearched(int id) {
        return searchedList.get(id);
    }
    
    
    /**
     * Adds gaps to the stored gap list associated with the poag.
     * @param start
     * @param end 
     */
    public void addGaps(int start, int end) {
        Integer[] gap = {start, end};
        gaps.add(gap);
    }
    
     /**
     * Gets the search indication for a node
     * @param id
     * @return 0 for not searched and -1 if it has been searched
     */
    public int setNodeSearched(int id) {
        return searchedList.put(id, -1);
    }
    
    
    /**
     * The nodes need to be reset to be not searched once we have the main path
     * and are looking for subsequent paths.
     */
    public void resetSearchList() {
        Set<Integer> keys = searchedList.keySet();
        keys.stream().forEach((Integer k) -> {
            searchedList.put(k, 1);
        });
    }
    
    /**
     * Initialise the search list to indicate none of the nodes have been 
     * searched yet (set all to 0)
     */
    private HashMap<Integer, Integer>  initSearchList() {
        HashMap<Integer, Integer> search = new HashMap<>();
        sorted = poag.sort();
        goalID = sorted[sorted.length - 1];
        startID = sorted[0];
        for (int i = 0; i < size; i ++) {
            search.put(sorted[i], 1);
        }
        return search;
    }   
    
     /**
     * The comparator for the queue. This stores then with the lowest cost as
     * the highest priority.
     */
    public class QueueComparator implements Comparator<QueueTiny<Object>> {

        @Override
        public int compare(QueueTiny<Object> o1, QueueTiny<Object> o2) {
            return Double.compare(o1.totalCost + o1.heuristicEstimate, 
                    o2.totalCost + o2.heuristicEstimate);
        }
    }
}
